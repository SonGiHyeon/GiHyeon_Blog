# GiHyeon_Blog

## 25.01.31 - OT

- OT
    - 전반적인 채용시장
    - 커리큘럼
    - 어떠한 채용 전략을 가지고 있는지
    - Github 사용법(마크다운 포함)
    - CLI

## 25.02.03 - 블록체인 역사와 개념 및 금융시장에 대한 이해

전반적인 블록체인의 역사와 개념 및 과거에서부터 현재까지의 금융시장과 그에 따른 비트코인의 등장 배경에 대해서 알아본 시간이였다.

아래는 상세한 정리본

- ### 사이버펑크 선언문

        무언가를 숨기기 위해서는 암호화와 암호화된 서명이 필요하다.
        
        정보는 이용 가능한 저장 공간을 채우기 위해서 확장되어 왔다.
        
        지식은 합의를 필요로 한다. 정보는 암호화 될 수 없다.

        사이버펑크는 코드를 사용한다. 비밀을 보호하기 위해서 소프트웨어를 사용한다. 
        소프트웨어는 널리 퍼져있는 장점이 있다. 
        사용자가 허용하지 않는 한 접근할 수 없다.
    
        사이버펑크는 암호학에서의 규제를 비판한다.
    
        사이버펑크는 익명 체계를 만들어냈으며, 익명과 디지털 서명 그리고 전자 돈을 사용해서 비밀을 지켜왔다.

- ### Before going in…

블록체인 => 혁신적인 기술? 탈중앙화? 무결성? 제일 중요한 것은 ‘신뢰’이다.

블록체인은 신뢰가 뒷받침 되어야 하는 기술이다.

- ### 비트코인은 최초의 블록체인이 아니다?

최초의 블록체인 아이디어: 디지털 문서의 타임 스탬프를 보장하기 위한 아이디어 
=> 스튜어트 하버 & 스콧 스토네타 제안

1989년 저명한 연구자의 ‘연구’ 결과가 조작된 것이라는 스캔들을 봄 => 다른 잉크 사용
=> 디지털 기록의 중요성 절감 => ‘디지털 기록의 불변성’에 대한 공동 연구 시작

‘연구’ => 시스템(서버): 해시 + 디지털 서명 
=> 데이터를 해시 -> 해시된 데이터를 타임스탬프 권한을 이용해서 기록 -> 타임스탬프 정보에 디지털 서명 -> 서명된 결과로 인해 ‘특정 시점에 이미 존재하던 데이터’임을 증명

시스템: 데이터들이 하나의 블록에 저장, 새로운 블록의 해시값은 이전 블록의 해시값을 포함함

두 연구자들은 이를 “문서 체인의 연결”이라는 문구를 논문에 인용하면서 ‘블록체인’이라는 용어가 사용됨

    1. 블록이라는 단위에 데이터가 담겨있음(데이터가 블록에 있음)
    2. 블록이 순서를 가지고 연결됨(블록의 해시값을 담고 있는 모습)

- ### 화폐의 역사

물건이 지니는 가치가 ‘교환’할 때마다 달라진다. 서로의 요구사항이 맞지 않으면 물건을 교환하지 못할 수도 있다.

### 1 - 실물 화폐

물건을 교환하는게 불편해짐 -> 특정 물건을 ‘화폐’로 정함 => 실물화폐

Ex) 조선시대의 실물화폐: ‘쌀’

실물화폐의 ‘문제점’

    1. 내구성이 없음
    2. 상품의 질이 같지 않음
    3. 휴대성이 없음	

=> 문제점들을 보완하기 위해서 ‘금속화폐’가 등장함

### 2 - 금속화폐 & 지폐

문제점: 산업과 기술의 발달 => 그 어떤 자원도 모든 금속 화폐를 공급하는게 불가능해짐
=> 동, 알루미늄, 니켈, 주석 등의 소재가 보조화폐가 되었고, 이후 중국에서 종이가 개발됨

### 3 - 신용 화폐

금속 => 실물 가치로서 교환하는 물건의 가치와 같을 수 없음 -> 가치 보장 ‘장치’ 필요

장치 => ‘국가’ => 사회적 신뢰나 국가의 법적 권위를 바탕으로 통용되는 화폐

발행 주체에 대한 ‘신용(신뢰)’이 가치의 근간이 된다.

신용화폐 => 신용을 매개로 한 실물이 없는 화폐 => 통제가 힘들어서 강력한 중앙기관의 통제가 필요하다.

### - 화폐가 가지는 특성 5가지

    1. 휴대성
    2. 가분성
    3. 내구성
    4. 동질성
    5. 가치의 안정성

### - 화폐의 3대 기능

    1 - 교환의 매개체 => 물물교환의 불편함을 없애고 보다 편히 물건을 교환할 수 있도록하는 기능
    
    2 - 가치 척도의 기능 => 화폐가 어떤 물건의 가치를 재는 ‘잣대’로써 기능하는 것
    
    3 - 가치 저장 기능 => 가치를 저장하는 수단

### - 화폐의 기능으로 본 암호화폐

화폐로서의 비트코인

    1. 교환의 매개체로서는 아직 부족하다 => 공식적인 방법을 통해 비트코인으로 물건을 살 수 있는 가게를 찾기 힘들기 때문
    2. 가치 척도 기능도 부족하다 => 큰 변동폭 때문
    3. 가치 저장 수단으로서 그나마 쓰이고 있다.(예를 들어 대한민국에서 ‘가상 자산’으로 인정한 부분)

### - 신용 창출(Credit Creation)

신용 창출(Credit Creation) => 은행을 통해 국가에 유통되는 ‘화폐 총량’이 늘어나는 현상

예금 창조(Deposit Creation) => 은행의 ‘신용’과 ‘예금’을 통해 유통되는 화폐의 양이 늘어나는 현상

    ‘본원통화’ => 한국은행이 직접 발행한 돈
    
    ‘지급준비금’ => 은행이 보유하고 있는 예금의 일정 부분(ex) 5%)을 지급준비금으로 보관하고, 나머지 금액(95%)만으로 대출을 해주는 것

시중은행이 예금된 금액을 사용해서 전체 통화량을 불리는 방법: 예금 -> 지급준비금을 제외한 나머지 금액 대출 -> 예금 -> 지급준비금을 제외한 나머지 금액 대출 반복
=> 신용이라는 힘이 화폐 가치를 증폭시키는 새로운 동력으로 작동하고 있다

### - 세계 금융 위기

서브프라임 모기지(Subprime mortgage)

2000년대 초반에 미국의 여러 가지 악재들로 인해 경기가 악화되자 경기부양책으로 초 저금리 정책을 펼치게 된다. 

당시 주택 가격을 아주 높인 상승률을 보이고 있는 상태 => 신용 등급이 낮은(Subprime)사람에게도 주택 담보로 대출(Mortgage)해주는 시스템이 생기게 되었다.

2004년 미국의 경제가 회복세에 접어듬 -> 초저금리 정책 종료 -> 서브프라임 사람들의 대출 상환 능력이 부족하게 되어서 결국 이 시스템을 유지하도록 하던 고객들의 능력이 안되자 결국 부동산 버블이 터져서 연쇄 파산으로 이어지며 세계 금융 위기가 시작되었다.
또한 대다수의 금융 회사들이 모기지 채권을 가지고 있었기 때문에 금융회사들도 엮여서 파산하게 된다.

### - 양적 완화

미국 연방준비제도(Fed)의 경기 침체 해결 방안

1. 재정 정책: 구제금융(Bailout) => TARP(Troubled Asset Relief Program): 부실자산(주로 서브프라임 모기지 관련 파생상품)을 보유한 대형 금융회사에 공적 자금을 투입
2. 경기부양책(Stimulus Package) => 오바마 행정부 초기(2009) 대규모 재정 지출(인프라 투자, 일자리 창출 프로그램 등)을 실행
3. 통화 정책: 양적 완화(Quantitative Easing: QE)와 초저금리
    - 초저금리: 정책금리를 거의 0% 수준으로 낮춰, 시중은행의 차입비용을 극도로 낮추는 것
    - 양적완화: 연방준비제도에서 화폐를 계속해서 찍어낸다 -> 찍어낸 화폐로 서브프라임 모기지에 있던 국채나 주택저당증권(MBS) 등을 대규모로 매입한다 => 시장에 많은 유동성 공급, 금리가 낮아짐, 기업 or 가계가 대출을 받을 수 있어서 경기 활동 활성화

### - 양적 완화 리스크

    1. 자산 가격 버블
    2. 인플레이션 위험
    3. 부의 양극화 심화
    4. 달러 가치 하락과 환율 문제
    5. 금융 시스템 왜곡
    6. 정책 의존성 증가
    7. 국제적 불균형 확대

### - 암호화폐의 등장(비트코인)

서브프라임 모기지 사태의 원인
    => 기관들의 판단에 의해 서브프라임 모기지 사태 발생
    => 국가의 사태 해결 정책으로 인해 의도치 않은 영향 발생

이러한 중앙화 시스템에 문제점이 있다고 인식하면서 이러한 시스템에 저항하는 사이버 운동을 준비하게 된다.

- 사이버 펑크(Cypher punk)

‘사이버 펑크’ => 개인의 프라이버시를 중요시 생각해 온 사람들

### - 주요 인물

    데이비드 차움: 디지털 서명을 활용해 익명의 전자화폐 개념을 제안
    웨이 다이: 탈 중앙화된 전자 화폐 시스템의 개념적 초안을 마련
    닉 재보: 작업 증명(Proof of Work)을 활용한 디지털 화폐의 설계 아이디어를 구현함

### - 사토시 나카모토의 등장

2008년 10월 31일 사이버 펑크 메일 리스트에 “Bitcoin P2P e-cash paper”라는 이름의 메일이 등장

메일 안에는 9쪽짜리 비트코인 백서(“Bitcoin: A Peer-to-Peer Electionic Cash System”)가 담겨 있었다

2009년 1월 첫 번째(제네시스 블록) 채굴을 시작으로 소스 코드 공개와 함께 세상에 처음 나왔다.

제네시스 블록 안에는 특별한 메세지가 있었다.

    “The Times 03/Jan/2009 Chancellor on brink of second bailout for banks”
    => The Times 2009/01/03 영국 재무부 장관의 은행에 대한 두 번째 구제금융

위의 메세지는 다음과 같은 의미를 내포했을 것으로 추측된다.

    1. 중앙화 금융 시스템에 대한 비판
    2. 탈중앙화 금융의 대안 제시
    3. 역사적 맥락을 기록

## 25.02.04 - 해시의 역할과 기능, 디지털 서명의 역할과 기능

해시의 역할은 데이터의 무결성을 증명하는 것이다.

### - Before going in…

스튜어트 하비와 스콧 스토네타가 고안한 블록체인은 암호화폐를 위한 것이 아닌 디지털 문서에 보장된 타임 스탬프를 찍기 위함이다.

### - 해시(Hash) => 타임 스탬프

해시(Hash)란? 데이터를 압축한 고정된 크기의 출력값(해시 값)이다. 해시는 주로 ‘데이터의 무결성’을 확인하거나 ‘암호학적 보안’을 제공하는 데 사용된다.

- 타임 스탬프 해시 과정

1. 데이터 준비 => 타임스탬프를 부여하려는 디지털 데이터 준비(Ex: txt, jpg…)
2. 데이터의 해시 값 생성  => 암호학적 해시 함수(Hash Function) 적용 => 해시 함수는 데이터를 고정된 길이의 ‘해시 값’으로 변환한다. 

	* 입력 데이터가 어떤 크기이든 상관없이 고정된 크기의 해시 값으로 압축된다.
	* 데이터가 조금이라도 변경되면 완전히 다른 해시 값이 생성된다.

3. 해시 값을 타임스탬프 기관(Timestamp Authority, TSA)에 제출 => 타임스탬프 기관은 논문 상에서 “신뢰할 수 있는 제 3자가 해시를 서명하고, 시간 정보를 포함하여 문서의 유효성을 보장”한다고 설명한다.

* TSA의 기능
	- 해시 값을 기록: 데이터의 원본 대신 해시 값만 저장하여 프라이버시를 보장
	- 타임스탬프 추가: 현재 날짜와 시간 정보를 해시 값과 결합
	- 디지털 서명: 타임스탬프 정보에 디지털 서명을 추가하여 데이터의 ‘무결성’과 ‘신뢰성’을 보장한다

4. 타임 스탬프와 해시 값 반환 => TSA는 사용자가 제출한 해시 값에 타임스탬프와 서명을 추가한 결과를 사용자에게 반환한다.

5. 데이터 검증 방법 => 데이터의 타임스탬프 검증 방법: 원본 데이터의 해시 값을 다시 계산(SHA-256으로 자신의 데이터를 해싱) => 계산한 해시 값과 TSA가 발행한 타임스탬프의 해시 값을 비교한다.

	* 해시가 동일? 데이터 변조 X
	* 해시가 동일 X? 데이터 변조 or 변경

6. 타임스탬프의 블록체인 활용 => 각 해시 값은 이전 해시와 연결되어서 체인을 형성한다.

	* 각 타임스탬프가 이전 타임스탬프의 해시 값을 포함하도록 설계 => 이렇게 하면 시간 
	순서가 기록되며, 이전 데이터의 무결성을 보장

 ### - 해시 함수(Hash Function)

- 해시 생성 방법: 해시 함수(Hash Function)이용 => 해시 함수: 임의의 길이를 가진 입력 데이터를 ‘고정된 길이’의 해시 값으로 매핑하는 함수

	* SHA-256 알고리즘: 어떤 입력값을 넣어도 256 비트 길이의(64자)의 값을 출력함
	* SHA-1 알고리즘: 160 비트 길이의(40자)의 값을 출력함

- 해시 함수의 특징
	
        1. 고정된 출력 길이: 모든 암호학적 해시 함수는 입력 데이터의 크기와 관계없이 고정된 길이의 출력(해시 값)을 생성한다.
        2. 충돌 회피: 서로 다른 입력 데이터가 동일한 해시 값을 가질 확률은 극도로 낮다.
        3. 역상 저항성(Preimage Resistance): 해시 값을 통해 원래 입력값을 역으로 계산하는 것이 계산적으로 불가능 * 역(거스를 역) 상(모양 상): 어떤 연산의 결과를 보고 거꾸로 원래 값을 찾아가는 개념
        4. 효율성: 현대 컴퓨터에서 빠르게 계산 가능(긴 데이터를 넣어도 결과를 빠르게 확인 가능)
        5. 강력한 보안성: 현재까지 실직적인 공격이 매우 어려움

- 해시 함수의 활용

        1. 블록체인: 비트코인 및 기타 암호화폐에서 데이터의 ‘무결성’을 보장하고 ‘체인’을 연결하는데 사용
        2. 디지털 서명: 데이터 인증 및 무결성 확인
        3. 암호화 저장: 중요한 데이터를 안전하게 저장
        4. 데이터 무결성 검증: 파일 다운로드 및 전송 중 데이터 손상 여부 확인

- SHA-256 알고리즘 작동 과정

        1. 입력 데이터 준비: 입력 받은 임의의 길이의 데이터는 고정된 크기(512비트 블록)로 처리되며, 필요한 경우 패딩(padding)을 통해 데이터를 맞춘다.
        2. 패딩: 입력 데이터를 512비트 블록으로 나누기 위해 패딩을 추가한다.
        3. 초기 해시 값 설정: 8개의 32비트 초기 해시 값을 정의한다. 
        4. 메시지 처리: 입력 데이터는 512비트 블록 단위로 처리된다.

	(a) 메시지 스케줄 생성

	=> 각 512 비트 블록은 32비트 단위로 나뉘며, 한 블록 당 16개의 워드(word)로 시작한다.
	* 워드: 비트 단위(정보 표현)

	=> 추가적으로 48개의 워드 생성 => 총 64개의 워드가 생성된다.

	=> 새로운 워드는 이전 워드의 XOR 및 시프트 연산으로 생성된다.

		* XOR(베타적 논리합): 입력 비트가 다를 때만 1(True)을 반환하는 논리 연산
  
		* 시프트 연산(Shift Operation): 비트 단위로 데이터를 왼쪽 또는 오른쪽으로 이
		동시키는 연산

	(b) 해시 압축 함수(라운드 연산)
	=> 초기 해시 값과 64개의 워드 그리고 라운드 상수(64개의 고정된 32비트 상수 값)이 
	Round function의 인자 값으로 들어가게 된다.

	* 라운드 상수: 소수(2~311)의 세제곱근의 소수점 부분을 32비트로 변환
	* Round Function: 메시지 블록을 처리하여 해시 값을 계산하는 핵심 연산
	* 초기 해시 값과 메시지 워드, 상수 값 등을 조합하여 새로운 해시 값을 생성하는 과정을 
	64번 반복한다. 이 때 초기 해시값은 라운드 초기 a, b, c, d, e, f, g, h로 각 대입되어 
	각 라운드를 거치면서 갱신된다.

- 최종 출력

* 최종 해시 값 갱신 => 라운드가 끝난 후 a, b, c, d, e, f, g, h 값을 초기 해시 값에
추가한다. => 모든 블록 처리가 완료되면, 초기 해시값을 연결하여 256비트(32바이트)의 
최종 해시 값을 생성한다.

초기 해시 값들은 64번의 Round를 거친 후 나오게 된다.

### - 해시 => 비트코인

- 블록 정보(블록 해시 값 생성 인자)

        1. 이전 블록 해시 값
        2. 머클 루트: 블록 내 모든 트랜잭션의 요약 값
        3. 타임스탬프
        4. 난이도 목표(해시레이트)
        5. 논스: 작업 증명을 완료하기 이해 반복적으로 변경된 값

=> 위의 데이터를 결합하여 SHA-256 해시 함수를 두 번 적용해서 블록 해시 값을 생성한다.
=> Block Hash = SHA256(SHA256(Block Header))

블록 해시의 역할은 블록 간 연결성을 유지하고, 변경된 데이터를 탐지한다.

- 작업 증명 => 비트코인 네트워크에서는 채굴자가 블록체인의 새로운 블록을 연결하기 위해서는 작업 증명(PoW)라는 해시 퍼즐을 풀어야 한다.

- 작업 증명 해시 함수의 입력 값

        1. 버전(ex: 비트코인 세그윗 업그레이드(소프트포크))
        2. 이전 블록 해시
        3. 머클 루트
        4. 타임스탬프
        5. 난이도 목표
        6. 논스: 이것을 계속 변경한다.

=> 위의 입력 값들 중에서 논스, 타임 스탬프 , 머클 루트가 해시 퍼즐을 어렵게 만드는 요인들이다.

- 트랜잭션 ID => 블록에 들어가는 각 트랜잭션에는 ‘트랜잭션의 변경 여부’를 확인하고, 무결성을 보장하기 위한 트랜잭션 ID값이 존재한다.

* 트랜잭션 데이터: 입력, 출력, 금액 등이 포함돼있다.

* 머클 트리: 블록에 포함된 모든 트랜잭션을 요약하며, 데이터 검증 및 효율적인 검색을 
가능하게 해주는 기술

- 비트코인 주소 생성: 비대칭키 암호화를 기반으로 생성, 비대칭키 암호화에서는 공개키와 비밀키가 사용된다. 
- 비트코인 주소는 공개 키를 SHA-256과 RIPEMD-160으로 해싱한 값으로 생성된다.

- 디지털 서명 => 트랜잭션의 무결성 보장, 소유권 증명하는데 핵심적인 역할을 함, 이 과정에서 쓰이는 것이 해시 함수이다.

- 디지털 서명 역할

	* 트랙잭션 데이터 해싱: 트랜잭션 데이터의 해시 값을 서명한다.
	* 서명 생성: 개인 키로 해시 값을 서명한다.
	* 서명 검증

### - 암호학의 역사

- 컴퓨터 시대의 암호화: 1990년대에 양자암호학의 등장
  
	* 암호 화폐에도 암호 기술이 많이 사용됨
	=> 해시 함수, 공개 키 암호화, 디지털 서명과 같은 다양한 암호화 기술을 사용하며,
	블록체인에 저장된 데이터의 ‘일관성’을 보호하고 거래를 ‘인증’하는 데 사용한다.
	=> 타원곡선 전자서명 알고리즘(Elliptical Curve Digital Signature Algorithm, 
	ECDSA)는 블록체인에 기록된 자산을 정당한 ‘소유주’만이 사용할 수 있도록 보장한다.
	

### - 대칭키 암호화 & 비대칭키 암호화

- 대칭키 암호화: 암호화 및 복호화를 할 때 동일한 키를 사용하는 방식 => 여러 사용자 사이에 공유된 단 하나의 키를 기반으로 동작한다.
  
- 대칭키 암호 방식 동작 원리

        1. 키 생성: 대칭키(비밀 키)를 생성한다. 이 키는 암호화 & 복호화에 모두 사용한다.
        2. 암호화: 평문 데이터를 입력받아 비밀 키를 사용하여 암호문으로 변환한다.
        3. 전송: 암호문은 안전하지 않은 네트워크를 통해 수신자에게 전송된다.
  	      	: 비밀 키를 아는 사람만 암호문을 복호화 할 수 있다.
        4. 복호화: 수신자가 동일한 비밀 키를 사용하여 암호문을 평문으로 복호화한다.

- 비대칭키 암호화: 공개키와 개인키를 한 쌍으로 사용하는 암호화 방식이다.
  
- 공개키와 개인키가 만들어지는 과정

        1. 개인 키를 난수 생성기를 통하여 생성한다(16진수 or Base58Check 인코딩을 이용하여 문자열로 변환한다)
        2. 개인키로부터 공개키를 생성한다(공개키는 타원 곡선 암호화를 기반으로 개인 키에서 파생된다.)
            => 개인키로 공개키 유추 가능, 공개키로 개인키 유추 불가능
        3. 공개키는 다시 해싱되어 주소(지갑)가 생성된다.(각 블록체인 네트워크에 맞는 주소 생성 과정(포맷?)을 거쳐서 생성된다)

- 공개키로 암호화
	
	* 송신자가 수신자의 공개키로 데이터를 암호화
	* 수신자는 자신의 개인키를 사용해 데이터를 복호화

- 개인키로 암호화
	
	* 송신자가 자신의 개인키로 데이터를 서명(암호화)한다.
	* 서명된 데이터는 수신자에게 전송된다.
	* 수신자는 서명된 데이터와 발신자의 공개키를 사용해 서명을 검증한다.
	* 이를 통해 데이터가 발신자로부터 생성되었고, 중간에 변경되지 않았음을 증명한다.


- 블록체인에서의 활용

        1. 블록체인에서 공개키 사용: 
        	=> 주소 생성: 개인키로 생성된 공개키는 블록체인 주소가 된다.
        	=> 검증: 서명 검증을 위해서 사용
        2. 블록체인에서 개인키 사용: 서명
        3. 자산 제어: 개인키를 이용해서 블록체인 자산의 소유권을 증명한다.

### - 디지털 서명(Digital Signature)

- 서명이란? ‘나’라는 사람이 문서를 확인하고 문서의 내용에 동의하며 문서가 변조하지 않았음을 보증하는 것
- 디지털 서명: 디지털 서명은 개인키를 사용하여 생성한다, 디지털 서명된 데이터를 수신한 사용자는 공개키를 사용해 서명을 검증함으로써 다음을 확인할 수 있다.

        1. 무결성 보증
        2. 진위성 확인

- 디지털 서명의 동작방식

        1. 해싱: 해시 값은 데이터의 고유한 요약 정보
        2. 서명: 무결성과 진위성 보장
        3. 검증: 송신자가 개인키를 이용해서 암호화하고. 수신자가 공개키를 이용해서 복호화 했을때의 해시값이 동일하다면 정상적으로 송신자에 의해 서명된 것임을 확인할 수 있다.

- 디지털 서명 시스템의 필요조건

        1. 알고리즘
        2. 구현
        3. 개인키

### - 디지털 서명 => 타임 스탬프

- 타임스탬프에서 디지털 서명의 사용 목적

        1. 데이터 무결성 증명: 서명 이용
        2. 시간 인증: 타임스탬프 이용
        3. 신뢰 제공: 서명 이용

- 디지털 서명의 사용 과정
    
        1. 데이터 해싱: 해시 함수 이용 => 데이터 크기 감소 및 디지털 서명을 위해서, ‘요약 정보’로 활용된다.
        2. 타임스탬프 생성: 생성된 해시 값을 타임스탬프 기관에 전송한다
        3. 검증: 타임스탬프의 공개키를 사용해 서명이 유효한지 검증하고, 데이터의 해시 값이 타임스탬프에 기록된 해시 값과 동일한지 확인한다.

- 디지털 서명에서 사용된 앙고리즘

        1. RSA or DSA
        2. 해시 알고리즘

### - 디지털 서명 => 비트코인

- 비트코인에서 디지털 서명의 역할

        1. 트랜잭션 무결성 보장
        2. 소유권 증명
        3. 탈중앙화된 검증

- 디지털 서명의 생성 및 검증 과정

	* 서명 생성

        1. 트랜잭션 데이터 준비
        2. 해싱
        3. 개인키를 사용한 서명
        4. 서명과 트랜잭션 데이터 전송

	* 서명 검증

        1. 트랜잭션 데이터 해싱
        2. 공개키를 사용한 검증
        3. 검증 결과 확인

- 비트코인에서 디지털 서명 활용의 특징

        1. ECDSA 사용
        2. 공개키를 이용해서 주소 생성
        3. 비교적 작은 서명 크기(64바이트)

<2/5> => 비트코인의 블록 정보와 정보에 대한 상세한 내용에 대해서 다룸

<### 블록 구조

블록 헤더가 담고 있는 정보: 이전 블록 해시, 타임스탬프, 논스, 버전, 머클 루트, 난이도

블록 바디가 담고 있는 정보: 트랜잭션 데이터, 구조, 코인베이스 트랜잭션

트랜잭션 데이터: 송금 요청을 기록, 검증

출력 인덱스: 지출할 UTXO

스크립트 서명: 소유권 증명을 위함: 공개키와 디지털 서명 필요

- 트랜잭션 데이터 흐름

**송신자는 개인키로 서명하여 이전 UTXO를 사용할 수 있도록 증명.**

**수신자는 자신의 개인키로 잠금 해제를 해야 비트코인을 사용할 수 있음.**

**네트워크 노드는 공개키와 서명을 검증하여 트랜잭션이 올바른지 확인.**

- 머클 루트

리프 노드에서부터 트랜잭션 데이터를 쌍으로 해시화한 값들의 집합체, 모든 트랜잭션들의 해시를 대표하는 값

노드중에서 하나만 위변조 되어도 머클루트값이 완전히 변하는 특성이 있다.
###>

## Before going in…

* 비트코인은 ‘블록체인 기술’을 실현한 최초의 사례

### Block => 헤더와 바디로 이루어져 있으며, 각 부분은 고유한 역할을 가지고 있다.

- 블록 헤더(Header) => 블록에 대한 ‘메타데이터’를 포함하고 있으며, 블록의 고유한 ‘식별자’ 역할을 한다. 크기는 ‘80바이트’로 고정되어 있다.

- 주요 구성 요소

* 이전 블록 해시(Previous Block Hash)
	- 이전 블록의 해시 값으로, 블록 간 연결성을 제공한다.
	- 체인 형성, 블록체인의 무결성 보장
* 머클 루트(Merkle Root)
	- 모든 트랜잭션의 해시를 결합하여 생성된 트리의 ‘루트 해시’값이다.
	- 블록 내 모든 트랜잭션이 변경되지 않았음을 ‘증명’한다.
* 타임스탬프(Timestamp)
	- 블록이 생서된 시간
	UNIX 타임스탬프 형식(초 단위)으로 저장된다.(1970/1/1 00:00:00 UTC 부터 경과한 	시간을 초 단위의 정수로 표현)
* 난이도 타겟(Difficulty Target)
    - 현재 블록 생성 ‘난이도’를 나타낸다.
    - 네트워크의 작업 증명 목표를 정의한다.
* 논스(Nonce)
    - 작업 증명에서 정답을 찾기 위해 변경되는 값
    - 정답 블록 해시를 찾기 위해 채굴자가 반복적으로 시도한다.
* 버전(Version)
	- 블록이 사용하고 있는 비트코인 프로토콜의 버전 정보

- 블록 바디(Body) => 블록에 포함된 ‘트랜잭션 데이터’를 저장한다

* 코인베이스 트랜잭션(Coinbase Transaction)
	- 블록을 생성한 채굴자에게 ‘보상이 지급되는 트랜잭션’
	- 항상 블록의 ‘첫 번째’ 트랜잭션으로 포함된다
* 일반 트랜잭션(Transaction)
    - 블록에 포함된 ‘모든 비트코인 전송 기록’
    - 트랜잭션 개수는 ‘네트워크 상태’와 ‘트랜잭션 용량’에 따라 달라진다.
* 트랜잭션 데이터 구조
	- 입력(Input)과 출력(Output)으로 구성, 각 트랜잭션의 상세한 내용이 포함

현재 비트코인은 한 블록 당 최대 4MB의 데이터를 처리할 수 있다.
	* 블록 헤더: 80바이트
	* 트랜잭션 데이터: 나머지 공간(1MB or 4MB) 차지

### 트랜잭션(Transaction) 

비트코인 블록체인의 ‘트랜잭션 구조’는 송금 요청을 ‘기록’하고 ‘검증’하기 위해 사용되는 데이터 구조다. 트랜잭션은 크게 ‘입력’과 ‘출력’으로 구성된다.

- 트랜잭션의 주요 구성 요소

1. 버전(Version)

	* 트랜잭션 형식 정의(숫자 필드)
	* 현재 버전은 2 or 1, 추후의 업데이트를 위해 사용
	* 크기: 4바이트

2. 입력(Input) => 입력은 트랜잭션이 사용하는 ‘이전 트랜잭션의 출력(UTXO: Unspent Transaction Output)’을 참조한다. 입력은 송신자의 ‘서명’이 포함된 정보다.

- 구성 요소

* 트랜잭션 해시(Transaction Hash)

	- 현재 트랜잭션이 참조하는 이전 트랜잭션의 ‘해시 값’
	- 크기: 32바이트

* 출력 인덱스(Output Index)

	- 참조하는 트랜잭션에서 어떤 출력(0으로 시작하는 인덱스)을 사용하는지 나타낸다. =>. 지출할 UTXO
	- 크기: 4바이트

* 스크립트 길이(Script Length)

	- 잠금 해제 스크립트(Unlocking Script, ScriptSig)의 길이를 나타낸다.
	- 크기: 가변

* 스크립트 서명(ScriptSig)

	- 이전 트랜잭션 출력의 ‘소유권’을 ‘증명’하기 위한 ‘서명’과 ‘공개키’로 구성된 스크립트
	- ‘공개키’와 ‘디지털 서명’이 포함

* 시퀀스 번호(Sequence Number)

	- 트랜잭션이 취소 or 수정될 가능성을 나타내는 필드, 거의 사용 X
	- 크기: 4바이트

3. 출력(Output) => 수신자에게 전달되는 비트코인 정보, 한 트랜잭션은 ‘여러 개의 출력’을 가질 수 있다.

- 구성 요소

* 출력 금액(Value)

	- 해당 출력에 포함된 비트코인 금액을 나타낸다.
	- 단위: 사토시
	- 크기: 8바이트

* 스크립트 길이(Script Length)

	- 잠금 스크립트(Locking Script, ScriptPubKey)의 길이를 나타낸다.
	- 크기: 가변

* 잠금 스크립트(ScriptPubKey)

	- 비트코인을 잠금(수신자의 주소를 설정)하는 스크립트(ex: 공개키 해시)
	- 일반적으로 P2PKH(Pay-to-Public-Key-Hash)스크립트 형식을 사용하며, 수신자의 주소를 포함한다.

4. 잠금 스크립트와 해제 스크립트 예시

=> P2PKH는 비트코인의 트랜잭션 유형으로 “공개키(해시값)에 비트코인을 보내겠다”라는 형식이다.

	* ScriptSig(잠금 해제 스크립트): 입력에서 사용됨, 이전 트랜잭션 출력의 소유권을 증명하기 위해 사용된다.(개인키로 증명(복호화?)
	* ScriptPubKey(잠금 스크립트): 출력에서 사용됨, 수신자에게 비트코인을 보낼 주소를 지정한다.(공개키로 암호화)

5. 트랜잭션 카운터(Transaction Counter)

	* 트랜잭션이 포함된 ‘입력’과 ‘출력’의 개수를 기록
	* 각 트랜잭션마다 ‘입력 개수’와 ‘출력 개수’를 별도로 저장, 트랜잭션 크기 빠르게 파악
	* 크기: 가변(1바이트 이상, 비트코인 직렬화 규칙에 따라 다름)

6. 잠금 시간(Lock Time => 미래의 특정 시점에 거래를 실행할 수 있도록 예약하는 기능

* 해당 트랜잭션이 유효해지는 조건
	* 특정 ‘블록 높이’ 또는 ‘타임스탬프’가 설정될 수 있으며, 이 조건이 충족되어야 트랜잭션이 유효하다.
	* 크기: 4바이트

- 트랜잭션 흐름의 요약

	1. 송신자는 ‘입력’에서 ‘이전 트랜잭션 출력(UTXO)’을 참조한다.
	2. 해당 입력에 ‘개인 키’로 디지털 서명을 생성하여 서명 스크립트(ScriptSig)에 포함한다.
	3. 송신자는 비트코인을 보낼 수신자의 주소를 ‘출력’에 지정하며, 잠금 스크립트(ScriptKey)를 생성한다.
	4. 수신자는 잠금 스크립트를 해제하기 위해 자신의 ‘공개키’와 ‘서명’을 제공해야 한다.
	5. 네트워크 노드는 ‘입력’과 ‘출력’의 ‘검증’을 수행하여 트랜잭션이 올바른지 확인한다.

### 비트코인 자금 출처 관리 시스템 - UTXO =

“아직 사용 안 된 상태의 비트코인은 보관되고, 사용한 상태의 비트코인은 사용된 것으로 기록에 남는다.”

- UTXO(Unspent Transaction Output) 
	=> 이전 트랜잭션에서 생성되었지만 ‘아직 소비되지 않은 출력’ 
	=> 비트코인 네트워크에서 사용자의 잔고와 트랜잭션을 추적하는 ‘기본 단위’

- UTXO의 역할

	* 잔고 관리: 사용자가 보유한 비트코인의 총량은 해당 사용자가 소유한 UTXO의 합계로 계산된다.
	* 트랜잭션 검증: UTXO는 트랜잭션의 입력으로 참조되며, 이미 소비된 UTXO는 다시 사용할 수 없으므로 이중 지불을 방지한다.

	* 이중 지불: 블록체인에서 한 번 사용된 암호화폐를 다시 다른 곳에서 사용하는 것을 시도하는 행위

- UTXO의 동작 방식

1. 생성:

	* 트랜잭션의 출력으로 새 UTXO가 생성된다.
	* 이 츨력은 특정 비트코인 주소로 잠겨 있으며, 해당 주소의 소유자만 이 UTXO를 소비할 수 있다.

2. 소비:

	* 트랜잭션의 입력(Input)은 기존 UTXO를 참조하여 소비한다.
	* 소비된 UTXO는 더 이상 유효하지 않으며, 새로운 UTXO가 생성된다.

- UTXO의 구조

	1. 금액: 비트코인 양
	2. 소유자 정보: 트랜잭션 스크립트(P2PKH) 형태로 저장된 소유자 정보
	3. 트랜잭션 ID: UTXO를 생성한 트랜잭션의 고유 식별자(TxID)
	4. 출력 인덱스: 트랜잭션에서 UTXO가 몇 번째 출력인지 확인하는 번호

- UTXO와 트랜잭션의 관계

	* 트랜잭션 입력: 기존 UTXO를 참조하여 해당 금액을 소비한다.
	* 트랜잭션 출력: 새로운 UTXO를 생성하여 수신자 또는 잔돈으로 보낸다.
	* 이중 지불 방지: 이미 소비된 UTXO는 다시 사용할 수 없으므로 ‘동일 금액을 반복 사용하려는 시도’를 방지한다.

- UTXO의 저장 및 관리

	* 잔고 계산: 잔고는 보유한 모든 잔돈 UTXO의 합계(SUM)로 계산된다.
	* UTXO 세트: 사용되지 않은 출력 목록(UTXO 세트)을 유지한다.
	* 저장소 요구 사항: 사용되지 않은 출력이 누적되어 UTXO 세트의 크기가 증가한다. 이는 저장소와 처리 부담을 증가시킨다.

- UTXO의 장점, 단점

* 장점

    - 보안성
    - 병렬 처리 가능

* 단점

    - 복잡한 잔돈 관리
    - 저장소 부담

- UTXO 컨텐츠와 연계되는 설명

* 스크립트


UTXO를 소비하려면 ‘스크립트 언어’(OP Code)를 통해 ‘트랜잭션의 유효성’을 확인해야 하며, 이 연산자 코드가 그 과정을 담당하게 된다.

* 연산자 코드

	- OP_CHECKSIG: 공개 키와 서명을 인자로 받아 트랜잭션 ‘해시 서명의 유효성’을 검증한다.
	- OP_EQUAL: 입력 값들이 같으면 1, 아니면 0 리턴
	- OP_DUP: 스택의 최상위 항목을 복제한다.
	- OP_HASH160: SHA-256 해싱, RIPEMD-160으로 해싱한다.
	- OP_VERIFY: 최상위 스택 값이 ‘참’이 아니면 트랜잭션을 ‘유효하지 않은 것’으로 표시
	- OP_EQUALVERIFY: OP_EQUAL과 동일하나, 나중에 OP_VERIFY를 실행
	- OP_CHECKMULTISIG: 첫 번째 서명을 인자로 받아 일치하는 키를 찾을 때까지 각 공개 키와 비교, 같으면 1, 아니면 0 리턴

### 머클 루트

- 머클 트리(Merkel Tree)
	=> 여러 데이터에 대해 단계적으로 해시 함수를 적용하여 최종적으로 ‘머클 루트’라는 하나의 ‘최상단 해시값’을 생성하는 데이터 구조
	=> 머클 트리는 블록체인에서 ‘데이터의 무결성을 보장’하고 ‘위변조를 방지’하기 위해 사용된다.

- 트랜잭션 해시값: 트랜잭션 데이터 전체를 두 번 SHA-256 해싱한 결과

- 머클 루트의 중요성

* 블록 헤더:

- 머클 루트는 블록 헤더에 저장, 블록체인 네트워크에서 작업 증명을 수행할 때 중요한 역할을 한다.

* 경량화된 노드(Light Node): 전체 블록체인을 다운로드하지 않고 머클 루트를 사용해 특정 트랜잭션의 유효성을 검증하는 노드

	* 변조된 머클 루트가 헤더에 반영
	* 연쇄적 변화 발생

   <2/6>

### 분산 원장

원장(Ledger)은 ‘거래’, ‘소유권’, ‘자산’ 등 다양한 데이터와 정보를 기록하고 관리하는 시스템(거래내역의 디지털화)

- 중앙 집중형 원장  

=> 데이터가 하나의 ‘중앙 기관’에 의해 관리되고 통제되는 방식

	1. 중앙화된 신뢰 => 중앙 기관의 ‘신뢰성’과 ‘권위’를 기반으로 형성
	
	2. 단일 장애점(Single Point of Failure) => 중앙 서버가 해킹, 손상, 장애를 겪으면 데이터가 ‘유실’되거나 ‘손상’될 위험이 있다.
	
	3. 효율성: 중앙 기관의 직접적인 데이터 관리 => 데이터 처리 속도 ↑
	
	4. 투명성 부족 => 독점적으로 관리하기 때문

사토시 나카모토는 효율성을 제외한 특징들을 해결하고 싶어했다.

- 분산 원장

1. 분산원장? 데이터를 네트워크의 여러 노드(참여자)에 걸쳐 ‘분산 저장’하는 데이터베이스의 일종 => 데이터는 동기화되고 복제되어 모든 노드에 공유, 무결성과 보안이 유지됨

2. 분산원장 특징

		* 분산성: 데이터가 여러 노드에 저장
		* 변경 불가능성: 변경 또는 삭제 ✕
		* 투명성: 모든 참여자가 동일한 데이터 관찰 가능
		* 탈중앙화: 합의를 통해 데이터 추가 or 삭제

3. 분산원장의 종류

		* 퍼블릭 분산원장: 누구나 접근 가능
		* 프라이빗 분산원장: 제한된 사람만 접근 가능
		* 컨소시엄 분산원장: 특정 그룹 내에서 공유된다, 참여 노드의 제한

- 분산 원장 기술(DLT, Distributed Ledger Technology)

=> P2P(Peer-to-Peer) 네트워크에 참여하는 여러 노드에 ‘분산 저장’하고 ‘관리’하는 기술

	* 합의 알고리즘
	* 암호화
	* 노드 동기화

- 분산 원장 기술의 작동 방식

		1. 트랜잭션 생성
		2. 트랜잭션 전파
		3. 합의 과정
		4. 데이터 저장

  ### 노드(Node)

=> 블록체인 네트워크에 연결된 컴퓨터

- 노드의 역할

1. 데이터 저장: 

		* ‘블록체인’이나 ‘분산 원장’에 기록된 데이터를 저장한다.
		* 풀 노드(전체), 라이트 노드(일부)

2. 데이터 검증:

		* 새로운 트랜잭션 & 블록 유효성 검증 => 네트워크의 무결성 유지
		* ‘검증된 데이터’만 네트워크에 추가될 수 있다.

3. 네트워크 연결 및 데이터 전파:

		* 다른 노드와 연결되어 데이터를 교환하고, 새로운 트랜잭션과 블록을 네트워크 전체에 전파한다. => 분산된 모든 노드가 ‘동일한’ 원장 데이터를 유지한다
		* 단일 장애점 제거 => 보안 강화

4. 합의 참여:

		* 일부 노드는 합의 알고리즘에 참여하여 트랜잭션을 ‘검증’하고 새로운 블록을 생성한다.=> 네트워크의 신뢰와 보안을 유지

- 노드 유형

* 풀 노드(Full Node)

=> 블록체인의 모든 데이터를 ‘저장’하고, 트랜잭션과 블록의 ‘유효성’을 독립적으로 검증하는 노드(ex: 비트코인 코어 노드)

* 라이트 노드, SPV(Simple Payment Verification)

=> 블록체인의 전체 데이터를 저장하지 않고, 필요한 최소한의 데이터만 저장하여 작동(모바일 지갑 앱)

* 마이닝 노드

=> 작업 증명을 수행하여 새로운 블록을 생성하는 노드

* 검증 노드(Validator Node)

=> 지분 증명 네트워크에서 ‘블록 생성’및 ‘검증’을 수행하는 노드

* 아카이브 노드(Archive Node)

=> 블록체인의 ‘모든 기록’과 ‘상태 데이터’를 저장하는 노드

- * 비잔틴 장애 허용(BFT, Byzantine Fault Tolerance)

- 비잔틴 장애: 분산 시스템에서 노드간 신뢰 문제 => 정직한 모든 노드가 합의에 어떻게 도달할 수 있는지를 설명하는 개념

- 비잔틴 장애 허용: 정직한 노드가 올바른 합의에 도달하여 시스템이 정상적으로 작동하도록 보장하는 시스템

- * PoW(Proof of Work)

=> PoW(작업 증명)은 네트워크 참여자가 복잡한 계산 문제를 해결하여 자신의 작업을 증명하고, 이를 통해 ‘합의’를 이루는 방식

- PoW 작동 방식

		1. 트랜잭션 모으기
		2. 퍼즐 문제 해결
		3. 블록 검증
		4. 보상 지급

- 체인 분기(Fork)

=> 하나의 체인이 두 개의 체인으로 분기되는 경우

	1. 두 명 이상의 채굴자가 동시에 블록을 생성하여 네트워크에 전파했을 경우
	2. 네트워크 지연으로 일부 노드는 특정 블록을 수신하지만 일부 노드는 뒤늦게 수신할 경우

- 분기 상태:

1. 두 체인의 길이가 동일, 각각 다른 노드 그룹에서 다른 체인을 ‘유효한 체인’으로 인식 => 이 상황에서 블록체인은 일시적으로 ‘체인 분기’ 상태가 된다.

=> 네트워크는 가장 긴 체인을 신뢰하게 된다.

- 체인 리오르기: 분기 체인 중 가장 긴 체인

- PoW의 장점

* 높은 보안성 => 네트워크 공격은 전체 해시 파워의 51% 이상이 필요, 이는 매우 높은 비용이 듬

* 검증 용이성: 단순히 블록 헤더의 해시 값을 계산 -> 블록이 타겟 값(난이도, Target) 조건을 만족하는지 확인

- PoW의 단점

		* 에너지 소비 ↑
		* 확장성 문제: TPS 7
		* 진입장벽: 고성능 하드웨어 요구, 전력 비용 ↑
		* 중앙화 문제: 해시 파워 51% 이상 가능성 존재

- 51% 공격 문제점

		* 블록 생성 독점
		* 이중 지불
		* 네트워크 방해

  ### PoS(Proof of Stake)

=> 네트워크 참여자의 ‘지분(Stake)’을 기준으로 블록을 생성하고 합의를 이루는 방식

- PoS의 작동 원리

* 블록 생성 과정

		1. 지분 기반 참여: 자신의 코인을 스테이킹 하여 ‘블록 생성 권한’을 얻음
		2. 검증자 선택: 무작위 알고리즘을 통해 블록 생성자 선택
		3. 블록 검증 및 추가: 선택된 검증자가 블록 생성, 다른 검증자들이 이를 검증하면 블록체인에 추가된다.

* PoS의 특징

		1. 지분 기반: 많은 지분 -> 블록 생성 확률 ↑
		2. 확률적 보상: 지분에 따른 보상

- PoS의 장단점

* 장점: 

		1. 에너지 효율
		2. 확장성
		3. 보안성

* 단점:

		1. 지분 집중화 문제
		2. 복잡성

- PoS의 보안성과 공격

* 보안 강화

		1. 경제적 패널티: 슬래싱
		2. 51% 공격 방지: 네트워크 과반수 지분을 확보해야만 함

=> 과반수 지분 확보가 어려운 이유:

	1. 경제적 비용
	2. 지분 위험성

- 잠재적 공격:

		1. Nothing as Stake 문제: 검증자가 여러 체인에 동시에 서명할 위험
		2. 초기 지분이 많은 참여자가 블록 생성에 유리

  ### DPoS(Delegated Proof of Stake) => 위임 지분 증명

=> 대표자(Delegate)를 선출하고, 이 대표자가 네트워크의 ‘블록 생성’과 ‘검증’을 담당하는 합의 알고리즘이다.

- DPoS의 작동 방식

		1. 대표자 선출
		2. 블록 생성과 검증
		3. 보상 분배
		4. 대표자 교체

- DPoS의 장단점

* 장점:

		1. 높은 효율성
		2. 에너지 효율
		3. 민주적 구조: 투표로 인함
		4. 실시간 조정 가능

* 단점:

		1. 중앙화 가능성
		2. 투표의 낮은 참여율
		3. 대표자 신뢰 문제

- DPoS의 보안

		1. 대표자 교체
		2. 경제적 인센티브
		3. 투명성

- 채굴: 

- 블록이 생성되는 과정

		1. 트랜잭션 생성 및 전파
		2. 트랜잭션 수집
		3. 블록 템플릿 생성
		4. 작업 증명(PoW)
		5. 블록 검증 및 전파
		6. 블록체인에 추가
		7. 보상 지급
		8. 새 블록 이후 체인 확장

  <2/7> 

### Before going in…

이더리움은 ‘프로그래밍이 가능한 블록체인’의 ‘선구자’ 역할을 한 블록체인이다.

### 이더리움 탄생 배경

- 튜링 완전성(Turing Completeness)

		=> 특정 시스템이 ‘튜링 기계(Turing Machine)와 같은 계산 능력을 가졌음을 의미
		=> 어떠한 계산 가능한 문제도, 적절한 ‘알고리즘’과 충분한 ‘리소스(시간과 메모리)’가 주어진다면 해결할 수 있다.

- 튜링 기계

		=> ‘앨런 튜링’이 제안한 ‘가상의 계산 모델’
		=> 현대 컴퓨터의 ‘계산 가능성;’을 설명하는 기초가 되는 개념

* 요소

		- 무한한 길이의 테이프(‘데이터 저장소’ 역할)
		- 읽기/쓰기 헤드(테이프의 데이터를 ‘읽고 쓸 수’ 있음)
		- 상태 머신(현재 ‘상태’와 ‘입력’에 따라 동작을 결정하는 규칙 집합)

‘튜링 기계’는 ‘이론적 컴퓨터’로 간주된다.

- 튜링 완전성의 조건

		1. 임의의 조건 분기(Conditional Branching)
		2. 임의의 루프(Arbitrary Loops)

- 튜링 완전성의 예

		1. 프로그래밍 언어(Python, Java…)
		2. 스마트 계약 플랫폼(Ethereum)

- 튜링 불완전한 시스템

		1. SQL(무한 반복 지원 X)
		2. 비트코인 스크립트(복잡성 감소와 보안을 위해서)

- 블록체인과 튜링 완전성

=> 복잡한 로직 실행 가능 but 보안 문제와 무한 루프 같은 자원 낭비 가능성

* 이더리움

		- EVM은 ‘튜링 완전성’ 지원 => 복잡한 스마트 계약 작성 가능
		- 가스 제한: 무한 루프 방지

* 비트코인

- 스크립트 언어는 ‘튜링 불완전’하다. => 보안성 높이고 ‘트랜잭션처리’에 초점을 맞추기 위해

- 비탈린 부테린

* 비탈린이 느낀 비트코인의 한계

		- ‘디지털 화폐’로써만 사용되는 기술
		- 비트코인의 ‘스크립트 언어’는 기능이 제한적 => 복잡한 ‘스마트 계약’이나 어플리케이션을 실행하기에는 부족

- 이더리움

* 이더리움의 핵심 목표

- 스마트 계약(Smart Contract)

		1. 누구나 조건 설정, 이를 자동으로 실행할 수 있는 프로그램을 블록체인 상에서 실행
		2. Dapp에 활용 가능

- Dapps

		1. 다양한 분야의 애플리케이션을 실행할 수 있는 플랫폼
		2. 프로그래밍 가능성
		3. 튜링 완전한 언어를 통해 블록체인 상에서 복잡한 프로그램 구현 가능

- 스마트 계약

		=> 블록체인 상에서 실행되는 자율적인 프로그램(특정 조건이 충족되면 자동으로 실행)
		=> 특정 규칙을 코딩하고 이를 블록체인에 배포, 실행할 수 있다.
		=> Dapps을 실행할 수 있는 플랫폼

- EVM

		=> 이더리움 네트워크에서 ‘스마트 계약을 실행’하는 환경
		=> EVM에서 실행될 코드를 작성하여 배포할 수 있다, 이 코드는 이더리움 네트워크의 ‘모든 노드’에서 동작한다.
		=> 이더리움의 ‘프로그래밍 가능성’의 핵심 요소

- 튜링 완전성

=> 스마트 계약: ‘튜링 완전한’ 프로그래밍 언어로 작성된다.

### 비트 VS 이더

- 주소

* 비트

		=> 곡선 알고리즘: ECDSA
		=> 해시 함수: SHA256 + RIPMD-160
		=> 주소 표현: BASE58 인코딩, 숫자 + 문자 조합

* 이더

		=> 곡선 알고리즘: ECDSA
		=> 해시 함수: Keccak256
		=> 16진수(40자), “0x”로 시작

- 이더리움 - 어카운트 기반 모델(Account-based)

=> 모든 사용자와 스마트 계약이 계정(Account)으로 표현, 계정을 통해 ‘상태(State)’와 자산을 관리한다.

- 계정의 종류

* 외부 소유 계정(Externally Owned Account, EOA)

		=> 개인이 소유한 계정, 비공개 키(개인키)에 의해 제어된다.
		=> 트랜잭션 생성 가능

* 스마트 계약 계정(Contract Account, CA)

		=> 특정 코드(Smart Contract)가 배포된 계정
		=> 트랜잭션이 발생하는 코드가 실행된다.

* 계정 상태:

		=> Nonce: 해당 계정에서 보낸 ‘트랜잭션 횟수’
		=> Balance: 계정에 저장된 이더의 양
		=> Storage: 스마트 계약 데이터
		=> CodeHash: 스마트 계약 코드

* 트랜잭션 방식

=> 계정 간에 트랜잭션을 보내 상태를 변경

- Nonce

* 비트코인

		1. 블록 헤더 구성
		2. 채굴에서의 역할
		3. 다른 필드 변경

* 이더리움

1. 트랜잭션 순서 관리:

=> 각 계정에는 ‘nonce’가 존재, 트랜잭션의 수를 나타낸다

2. 재사용 방지:

=> 동일한 nonce 값을 사용하는 트랜잭셔은 네트워크에서 거부, 이를 통해 ‘재생 공격(Replay attack)을 방지

3. 병렬 트랜잭션 처리:

=> 여러 트랜잭션 동시 발생: nonce는 트랜잭션 순서를 결정하는 데 사용됨

- 보안

이더리움 - 재생 공격 방지: 재생 공격은 ‘트랜잭션 데이터를 복사하여 다른 네트워크나 상황해서 다시 실행’하는 공격 방식

* 방지 방법: 

		1. Nonce 사용
		2. 체인 ID

### EVM(Ethereum Virtual Machine)

가상 머신: 우리가 작성한 코드와 컴퓨터(하드웨어) 사이에 ‘추상화 계층’을 생성하는 역할

		=> 우리가 작성한 코드와 이더리움 블록체인 사이에 존재하는 ‘가상 머신’
		=> EVM은 이더리움 블록체인에서 ‘코드가 실행될 수 있도록 돕는다’

=> Solidity 코드 -> Solc를 이용해서 바이트코드로 컴파일 -> 바이트코드 -> 이더리움 네트워크로 배포

- 바이트코드 동작방식

		=> ‘스택’ 기반 아키텍처
		=> 명령어를 Opcode(명령어의 축약된 코드)로 해석
		=> 모든 연산을 ‘스택’을 이용해 처리

- EVM의 보안성과 가스(Gas)

1. 보안 격리(Sandboxing)

* 스마트 계약 간 충돌을 방지하며, 잘못된 코드가 네트워크나 다른 계약에 영향을 미치지 못하도록 ‘격리된 실행환경’을 제공한다.(안전성과 안정성이 강화된다)

2. 가스(Gas)

* 바이트코드 실행에는 ‘가스 비용’이 소모된다. 이는 네트워크 자원의 낭비를 방지하고, 효율성을 유지하기 위한 메커니즘이다.

### 스마트 컨트랙트(Smart Contract)

		=> 자동화된 계약 실행 프로토콜
		=> 코드로 구현된 계약을 통해 간단하고 빠르고 정확하게 계약을 이행할 수 있다.

장점 & 단점

* 장점

		1. 보안
		2. 신뢰성
		3. 공평함
		4. 효율성

* 단점:

		1. 수정 불가능
		2. 외부 정보를 가져오지 못함(해결책: 오라클(믿을만하지는 않음))












		














 









